[toc]

#命令模式
##参考资料
- [参考](https://www.javaworld.com/article/2077569/java-tip-68--learn-how-to-implement-the-command-pattern-in-java.html)
##分析
###优势
- 解耦请求者与接收者，在本例中，Switch是请求者，有两个请求：打开和关闭；Fan、Light是接收者，代表具体的物体、业务，可变化的
    - 为什么要解耦呢？
        - 如果不解耦，会出现什么情况。显然，如果要通过Switch来打开和关闭Fan、Light，Switch必须依赖这两个类，要知道，这两个是具体的类，就产生了
           高度耦合的情况，如果想增加一个电器，同时又想使用Switch来控制打开和关闭，不解耦的话，只能在Switch中的打开和关闭方法中增加对应的逻辑代码，这样就不符合开闭原则了，也不好扩展
        - ok，怎么解决这个问题呢，自然是解耦了，该怎么解呢？
           首先想到的，应该就是不让Switch直接依赖具体类，让它依赖一个接口（Command），然后在Switch的两个方法中写一些对这个接口调用的代码，此时，已经达到了不依赖
           具体类的目的了。
           然后，Fan、Light这些具体类怎么受Switch控制呢，因为Switch依赖一个接口（Command），那就创建一个实现该接口的类，比如FanOnCommand，扔给Switch，调用Switch
           的打开和关闭方法就可以触发实现了Command接口的FanOnCommand，而之前的业务就可以写在FanOnCommand实现的接口方法中，这样的话，如果想打开一个Light，
           提供一个LightOnCommand扔给Switch，Switch也可以控制Light的开启了，换句话说，Switch可以控制任何实现了Command接口的类了。
###劣势
- 只是每个具体类，如果想被Switch控制，就需要提供与Switch方法相同个数的类，代码量就上去了

###使用场景
- 用户对一个业务流程进行操作，在页面上点击不同的按钮，即发出不同的命令，发出命令的东西有一个名字：引擎
- 使用框架：activiti
###对比分析
- Switch好像是一个遥控器，每点一个按钮，就发送一个命令出去，至于谁会拿这个命令干点啥，它是不关心的；照这么看来，它也属于生产者/消费者模式，生产者发送一个消息，就不管了，对这个消息感兴趣的消费者会作出相应处理。
生产者/消费者模式的另一种实现是消息队列，它和命令模式就很像了。

|   | 命令模式    | 消息队列     |   
| -------- | --------- | ----------- | 
| 使用范围  |   应用内部，一个application    |     既可以应用内部，也可以应用之间，系统之间     
| 实现模式  |   生产者/消费者模式    |     生产者/消费者模式      |       
| 实现原理  |   java 多态性    |     各种消息中间件      |     
|定义|         只是一种编程经验|一种系统架构的解决方案
